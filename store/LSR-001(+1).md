# Lamina增强提议 Lamina001(+1)
**标准规范**

**@azhz1107cat**

**草案**

**2025-8-16**

## 摘要

---
在Lamina持续发展的过程中，为进一步完善语言功能、提升使用便捷性与灵活性，现提议引入以下新语法特性。
## 议案一：类型注释

---
### 应用场景：
需明确指定变量类型以实现强类型约束时。
### 核心语法：
```
var name: type = expression;
```
使用示例：
```
var a: int = 100;  // 明确变量a为int类型
```
### 其他可选方案：
```
var name = expression as type;  // 以as关键字指定类型
```

```
var name = expression is type;  // 以is关键字指定类型
```
## 议案二：泛型支持

---
### 应用场景：
需编写适用于多种类型的通用代码（如通用函数）时。
### 核心语法：
```
func add[T](a:T, b:T) -> T{
    return a+b
}
```
### 其他可选方案：
```
template[T]  // 以template关键字声明泛型
func add(a:T, b:T) -> T{
    return a+b
}
```
## 议案三：类型注释类型

---
**支持的基础类型注释包括：**

	: int（整数）

	: float（浮点数）

	: r（有理数）

	: irr（无理数）

	: complex（复数，未来可扩展）

	: bool（布尔值）

	: str（字符串）

	: arr[_SubType]（数组，_SubType为元素类型）

## 议案四：待添加类型——表/点阵

---
### 类型标识：: 
```
lattice[_SubType]（_SubType为元素类型）
```
### 使用示例：
```
var my_lattice: lattice = [
1,2,3,4,5,6,7;
8,9,10,11,12,13,14;
];
```

```
my_lattice[1,2] // 取值为2（索引从1开始）
my_lattice.nearby(3,"down") // 取值为10（获取3下方的元素）
my_lattice.nearby(3,"left") // 取值为2（获取3左侧的元素）
```
### 其他可选方案：

```
: table[_SubType]（以table作为类型标识）
```

## 议案五：待添加类型——映射

---
### 类型标识：

```
: map[_KeyType, _ValueType]（_KeyType为键类型，_ValueType为值类型）
```
### 使用示例：
```
var class_mate: map[str, int] = {
 "Tom": 17,
 "Mike": 18
};
```

```
class_mate["Tom"] // 取值为17（通过键获取值）
class_mate[:1] // 取值为"Tom"（获取第1个键）
class_mate[::1] // 取值为17（获取第1个值）
```
### 其他可选方案：

```
: dict[_KeyType, _ValueType]（以dict作为类型标识）
```

## 议案六：结构体

---
### 核心语法：
```
struct Name{
    item_name: type  // 结构体成员及类型定义
};
```
### 使用示例：
```
// 命名结构体
struct Dog{
    weight: int,
    height: int,
    width: int,
    master: str
};

// 匿名结构体
var x = {
  weight = 100,
  master = "Tom"
};
```
## 议案七：高阶函数

---
### 类型标识：

```
: callable[_ReturnType, ArgumentsType]（_ReturnType为返回值类型，ArgumentsType为参数类型列表）
```
### 基本语法：
```
// 常规形式
do |arguments| {
    statements
};

// 简写形式
|argument| => statement
```
### 使用示例：
```
// 简写形式定义函数
var float_add: callable[float, [float,float]] = |a,b| => a+b

// 常规形式定义函数
var int_add: callable[int,[int,int]] =
do |a,b| {
    return a+b
}
```
### 其他可选方案：统一使用箭头函数语法
```
(arguments)=>{
    statements
};
```
## 议案八：装饰器

---
### 核心语法：
```
@function_name  // 装饰器函数
func name(arguments){
    statements
}
```
### 使用示例：
```
@pure  // 标记函数为纯函数（无副作用）
func add(a,b){
    return a+b
}
```
## 议案九：编译/解释器模式

---
### 语法标识：
```
#[pattern]（通过注解指定模式）
```
### 常见模式：

	•	#[breakpointer]（断点模式，用于调试）

	•	#[stricttype]（严格类型模式，强制类型检查）

### 使用示例：
```
print("start")
#[breakpointer]  // 启用断点模式
print("end")  // 调试模式下不会执行到该语句
```
## 议案十：内联Latex

---
### 类型标识：

```
: latex（用于存储Latex公式）
```
### 语法形式：
```
var name: latex = latex_formula  // 直接赋值Latex公式内容
```
### 示例：
```
var x: latex = 
\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}  // 二次方程求根公式
```
## 议案十一：管道运算符

---
### 作用：
将左侧表达式的结果作为右侧函数的输入，实现链式操作。
### 示例：
```
var x = 100
var y: float = 
x |> sqrt |> pow |> sqrt |> float  // 依次执行开方、幂运算、开方，最终转为float类型
```
## 议案十二：模式匹配

---
### 核心语法：
```
when _var{  // _var为待匹配的变量
    pattern => statements  // 匹配模式及对应执行语句
}
```
### 规则：

	•	when语句的结果可赋值给变量

	•	若无break语句，默认执行所有匹配的情况

	•	不创建独立作用域

### 使用示例：
```
when my_num{
	is int => print("it is an int");
    is r   => print("it is a rational number");
    is irr => print("it is an irrational number");
    100    => print("its value is 100");
    200    => print("its value is 200");
     _     => print("Can't macth the var"); // 缺省语句
}

// 当my_num = 100时，输出：it is an int its value is 100
```
## 议案十三：多线程与异步方案

---
提议支持三种主流并发模式，可根据场景选择：

	•	类JavaScript的异步非阻塞与多线程（关键字：async await）

	•	类Go语言的并发模型（关键字：chan go delay select）

	•	Actor模型（关键字：spawn send receive）

## 议案十四：小数截断（语法糖）

---
### 作用：
快速截断小数位数，简化精度控制。
### 使用示例：
```
var x = 3.14159~2f;  // 保留2位小数，结果为3.14
```
## 议案十五：自动分号系统（语法糖）

---
引入类似JavaScript的自动分号插入机制，减少手动输入分号的冗余操作，提升编码效率。

## 议案十六：重写大整数系统

---
### 原先
使用字符串实现
### 提议
使用类似py的数组机制实现